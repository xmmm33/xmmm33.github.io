{"meta":{"title":"学习笔记","subtitle":null,"description":null,"author":"xmmm33","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"初识Spring","slug":"初识Spring","date":"2018-08-14T03:49:54.000Z","updated":"2018-08-15T11:19:05.231Z","comments":true,"path":"/myblog/2018/08/14/初识Spring/","link":"","permalink":"http://yoursite.com/myblog/2018/08/14/初识Spring/","excerpt":"","text":"什么是Spring Spring是一个开源的轻量级的框架，Spring的核心主要两部分aop、ioc； aop：面向切面编程，扩展功能不是修改源代码实现； ioc：控制反转，比如说有一个类，在类里面有一个非静态方法，调用类里面的方法，我们需要创建累的对象，使用对象调用方法；要new对象；而ioc就是把对象的创建不是通过new，二是交给Spring配置完成创建类的对象； Spring是一站式框架，它在javaee三层结构中，每一层都提供了不同的解决技术； web层：SpringMVC service层：Spring的ioc dao层：Spring的jdbcTemplate Spring的ioc操作 把对象交给Spring进行管理；ioc操作的两部分： ioc的配置文件方式 ioc的注解方式 ioc底层原理使用技术： xml文件的配置； dom4j解析xml； 工厂设计模式； 反射； 这是使用普通的方式来创建对象，使用对象的方法，耦合度太高了；虽然出现了工厂设计模式来解耦合，但还是不够，这就出现了ioc； ioc实现原理： ioc实现步骤 导入jar包； 创建类，在类里面创建方法； 创建Spring配置文件，配置创建类；建议放到src下面，一般为applicationContext.xml需要引入schema约束； 写代码测试对象创建； Spring的bean管理（基于配置文件） bean实例化的方式：有三种方式： 使用类的无参数构造创建（常用）； 使用静态工厂创建；创建静态的方法，直接使用工厂类名引用静态方法，返回类对象； 使用实例工厂创建；创建非静态方法，需要使用创建工厂对象来引用方法，返回类对象； bean标签常用的属性： id属性：起的名字，不能包含特殊符号 class属性：创建对象所在类的全路径 name属性：和id属性的功能一样，但name能包含特殊符号 scope属性：bean的作用范围，默认为单实例对象singleton；还有多实例对象属性prototype；request属性值表示把创建的对象放到request域中去等； 属性注入 就是在创建对象的时候，向类里面属性设置值，这就是属性注入；属性注入的三种方式：1.使用set方法注入；2.用有参数构造器注入；3.使用接口注入；在Spring框架里面，只支持前两种方式； 在Spring框架中： 1.使用有参数构造器属性注入，配置文件如下图： 2.使用set方法进行属性注入，配置文件如下图：这个方式在开发中最常用； 3.注入对象类型的属性：下图是一个在userService的类里面注入userDao对象的例子，Spring配置文件的书写规范： IOC和DI的区别 ioc：控制反转，把对象创交给Spring进行配置 DI：依赖注入，向类里面的属性中设置值 两者的关系：依赖注入不能单独存在，必须在ioc的基础上完成操作 Spring整合web项目原理 实现目标：把加载配置文件和创建对象过程在服务器启动时候完成； 实现原理：在服务器启动的时候，为每个项目创建一个ServletContext对象；在ServletContext对象创建的时候，使用监听器可以具体到ServletContext对象在什么时候创建；当监听器监听到ServletContext对象创建的时候，就加载Spring配置文件，进行配置文件里的对象创建，把创建出来的对象放到ServletContext域对象里面，setAttribute方法；获取对象的时候使用getAttribute方法； Spring的bean管理（基于注解方式） 第一步：配置Spring配置文件 第二步：注解创建对象；在创建对象类的上面加上注解；一共有四个注解； 通过注解方式注入属性-@Autowired、@Resource 在对象的属性上面使用注解完成对象的注入；第一步是注解创建对象，第二步是注解注入属性； 注意： 在项目开发中，一般使用配置文件和注解混合使用；创建对象操作使用配置文件方式实现，注入属性的操作使用注解方式实现； AOP 什么是AOP：面向切面编程，采取横向抽取机制，而AOP采用的是横向抽取方式，其底层使用的是动态代理方式； AOP主要术语 连接点：类里面哪些方法可以被增强，这些方法就称为连接点； 切入点：在类里面可以有多个方法被增强，在实际中，只增强了类里面某几个方法，这几个方法称为切入点； 通知/增强：增强的逻辑，称为增强，比如说我们在某一个方法上扩展了一个日志功能，这个日志功能就称为增强； 切面：把增强应用到具体的方法上面，这个过程称为切面； 比如在上图中，add这些方法可以被增强，就成为连接点；比如我增强了这个User类里面的add和findAll方法，则这两个方法称为切入点；通知，即我给add增强的功能，比如说一个日志功能；切面，指我把日志功能应用到这个add方法这个过程称为切面 Spring的AOP操作 在Spring中使用aop操作，使用AspectJ来实现，这不是Spring的一部分，只是说要和Spring一起来使用，进行aop操作；使用aop操作之前，需要导入相关的jar包，配置对应约束； 使用aspectj实现aop的两种方式： 基于aspectj的xml配置 基于aspectj的注解方式","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"http://yoursite.com/tags/学习日记/"}]},{"title":"初识Hibernate","slug":"初识Hibernate","date":"2018-08-14T03:49:29.000Z","updated":"2018-08-15T02:21:06.702Z","comments":true,"path":"/myblog/2018/08/14/初识Hibernate/","link":"","permalink":"http://yoursite.com/myblog/2018/08/14/初识Hibernate/","excerpt":"","text":"Hibernate 什么是hibernate hibernate是一个开源的轻量级的框架；它是应用在DAO层的框架，在DAO层里做对数据 库的crud操作；其实它的底层代码就是JDBC代码，hibernate就是对它进行了封装；不 需要写sql语句实现了。 hibernate的思想-orm object relational mapping，对象关系映射；让我们的一个实体类bean和数据库进 行一一的对应；这个对应，即实体类与数据库表名对应；实体类属性和表里的字段一一 对应；原始的jdbc代码要像下图这么来写： 而hibernate实现这个操作只需要使用配置文件使实体类与数据库表一一对应起来就行 了，不需要操作表，而去操作表对应的实体类对象就行了，在调用hibernate的封装的 对象的方法来实现操作； 初识hibernate配置文件 mapping配置文件命名标准一般为实体类名.hbm.xml；这是一个简单的hibernate xml 映射文件； hibernate核心配置文件：位置必须在src下面，名称必须为hibernate.cfg.xml跟Struts2类似； 在这个文件里面要引入映射文件；结构如下图； hibernate核心api Configuration对象就是加载核心配置文件; 使用Configuration的对象可以创建sessionFactory对象；根据核心配置文件到数据库 中把表创建出来；创建sessionFactory的过程中，特别耗费资源； session：类似于jdbc中的Connection；里面有多个方法，实现crud操作；session是 单线程对象，不能共用； Transaction事务对象，主要两个操作，事务提交和回滚；事务的四个特性：原子性、 一致性、隔离性、持久性（简称ACID）； 事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的 所有更改都会被撤消。 Query对象；使用query对象，不需要写sql语句，需要些hql语句，sql语句是对数据库的 表和表里的字段进行操作；而hql语句是对实体类和实体类的属性进行操作； 原子性：也就是指一个事务中的一系列操作要么全部成功，要么一个都不做，不能只执行其中一部分操作； 一致性：就是指事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态，换句话说就是数据库只包含成功提交事务的结果时，就说数据库处于一致性状态 隔离性：即一个事务内部的操作对于其他并发的事务是隔离的、不影响的；如果不考虑隔离性的话会产生脏读、虚读、不可重复读问题； 持久性：指一个事务一旦提交了，它对数据库中的数据的改变就是永久性的，即使系统崩溃，修改的数据也不会丢失； hibernate的实体类编写规则 大致跟javabean的编写一致；但需要注意以下几点： 要求实体类有属性作为唯一值，即唯一属性； 实体类属性最好使用基本数据类型的包装类型，不要使用基本类型； 实体类对象的三种状态 瞬时态：对象里面没有id值，与对象session没有关系； 持久态：对象里面有id值，对象与session有关系； 托管态：对象有id值，但对象与session没有关系； hibernate缓存 hibernate中的缓存是一个优化方式； hibernate的一级缓存：默认是打开的；它的使用范围就是session范围，以创建session开始到session关闭为止；在一级缓存中存储的数据必须是持久态的数据；持久态数据会自动更新数据库；执行过程如下图： hibernate的二级缓存：已经不适用了，已经用redis技术来替代了； hibernate事务代码规范写法 try{ 开启事务 提交事务 }catch（异常）{ 回滚事务 }finally{ 关闭 } hibernate绑定session session类似于jdbc的Connection；获取与本地线程绑定的session： 首先在核心配置文件中配置； 调用sessionFactory中的方法得到； 注意：当你获取与本地线程绑定的session的时候，线程结束会自动关闭session，如果你手动关闭了，系统会报错，如下图： hibernate的查询方式 对象导航查询：根据id查询出某个客户，再查询这个客户里面的所有联系人； OID查询；根据id查询某一条记录；返回对象； hql查询：使用hibernate的query对象，写hql语句实现查询；hql操作实体类对象和实体类属性；一般步骤为创建Query对象，编写hql语句，调用query的方法得到结果； QBC查询：使用criteria对象查询； 本地sql查询：SQLQuery对象，使用它来查询；","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"http://yoursite.com/tags/学习日记/"}]},{"title":"Struts2初级应用","slug":"Struts2初级应用","date":"2018-08-13T01:26:48.000Z","updated":"2018-08-13T08:29:43.430Z","comments":true,"path":"/myblog/2018/08/13/Struts2初级应用/","link":"","permalink":"http://yoursite.com/myblog/2018/08/13/Struts2初级应用/","excerpt":"","text":"结果页面的配置全局结果页面配置 全局结果页面的配置，这个的出现是因为当有两个或多个action的返回值相同，并且转到的 页面也相同的时候，单独使用常规配置是能完成功能实现的，但这样会造成重复的代码出现； 所以这时候就需要配置全局结果页面，使用到的标签为&lt;global-result&gt;&lt;/global-resul t&gt;；在这个标签里面写入result标签，把多个具有相同返回值的action并且转到的页面是相 同的多行代码，写入一行就行了，其他action中的result标签就可以注释掉了，减少了重复 的代码出现，如下图； 局部结果页面配置 当配置了全局结果页面和局部结果页面时，而且具有相同的返回值的时候，这时候以局部结果 页面配置为准； Result标签中的type属性 这个type属性是配置是定义我们如何到对应的页面当中去；默认值为请求转发；dispatcher 还有一个值是redirect，重定向地址栏会发生变化，相当于两次请求；上面的这两个值是配 置到某个页面的用法，但我们在开发用需要配置到其他action；分别为chain和redirectA ction；第一个一般不用； redirectAction：重定向到另一个action； Action获取表单获取的数据 在servlet中，使用的request对象来获取；action中没有直接引入request对象，我们需 要来手动获取；有三种方式：1.使用ActionContext类 2.使用ServletActionContext类 3使用接口注入的方式； ActionContext：先使用ActionContext.getContext方法获取到ActionContext对象， 再使用 对象.getParameters方法，返回一个map，这个map中的key为 表单输入项中的name属性值，value为你输入的值； ServletActionContext：使用ServletActionContext.getRequest方法获取request 对象，然后使用request的getParameter方法来获取表单数据 使用接口注入方式（不常用）：让你的action实现ServletRequestAware接口，得 到request对象，后面操作同上； Struts2提供的封装获取表单数据的方式 原始方式如图： 属性封装 直接把表单提交的属性封装到action的属性里面；在action成员变量的位置定义 变量，变量名称和表单的name属性值相同，然后生成get、set方法，这个方法的方便之处就 是在获取数据的时候方便，但要放入对象中去的时候，还是要写必要的代码。 模型驱动封装方式 直接把数据封装到实体类对象当中去；接口中泛型为实体类的名称；手动常见实体类对象，然 后返回创建的实体类对象；前提要求是表单里的name属性值要和实体类中的属性名称一样； 这个方法在开发中是最常用的；其底层还是用的原始方式； 注意：不能同时使用上两种方式操作同一个表单数据，如果同时使用，会使用模型驱动封装； 表达式封装 也可以直接把表单数据封装到实体类中；在action中声明实体类，生成这个实体类变变量的 get、set方法，在表单输入项name属性处输入表达式形式；如下图； 封装数据到List集合 在action中声明List，生成list的get、set方法，在表单输入项中写表达式；用的比较少； 封装数据到Map集合 在action中声明map，生成map的get、set方法，在表单输入项中写表达式；也用的比较少； 值栈OGNL概述 EL表达式可以在jsp中获取域对象里面的值； OGNL表达式更强大了；在struts2里面操作值栈数据，一般与struts2标签一起使用； OGNL不是struts2的一部分，但常和struts2一起来使用； 引入标签库，如图 例子计算一个字符串长度；如图；value里面的值就是ognl表达式； 什么是值栈 在struts2里面提供本身一种存储机制，类似于域对象，是值栈，可以存值取值； 在action里面可以把数据放到值栈里面，在页面中获取到值栈数据； servlet和action的区别，servlet默认在第一次访问的时候创建，创建一次，单实例 对象；action访问时创建，每次访问action的时候都会创建action对象，创建多次，多 实例对象； 每次访问action的时候，都会创建action对象，在每个对象里面都会有一个值栈对象，就相 当于说值栈存储于每个action里面； 如何获取到值栈对象 使用ActionContext类里面的方法得到值栈对象；这是最常用的方式；使用方式如下图； 每个action对象里面只有一个值栈对象； 值栈内部结构 值栈分为两部分 1.root 本身结构是list集合 2.context 本身结构是map集合； 一般操作的都是root里面的数据；可以在jsp页面中使用debug标签来查看值栈的内部结构； 向值栈放数据 有多种方式，可以调用值栈对象的set和push方法；但是主要采用的是在action定义变量 ，生成变量的get方法，如下图： 注意：如果采用值栈对象的set和push方法来存储数据，会重新分配空间，而第三种方式是 直接在你的action中存储，相对于前面两种方式，可以节约存储空间； 向值栈中放对象 实现步骤，首先定义对象，然后生成对象的get方法，最后在执行的方法中来对对象进行赋 值； 向值栈中放List集合 实现步骤，定义list集合变量，生成变量的get方法，在执行的方法中对对象进行赋值； 从值栈中取数据 - 获取字符串：使用struts2标签和ognl表达式获取值栈数据； &lt;s:property value=&quot;ognl表达式&quot;/&gt;; 其中value的值为字符串对象变量的名称； - 获取对象： - 获取List集合：第一种方式： - 第二种方式： - 第三种方式：最常用的方式，它会在context中分配一个临时空间给list key为var的值；","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"http://yoursite.com/tags/学习日记/"}]},{"title":"初识Struts2","slug":"初识Struts2","date":"2018-08-10T06:45:19.000Z","updated":"2018-08-10T10:30:14.332Z","comments":true,"path":"/myblog/2018/08/10/初识Struts2/","link":"","permalink":"http://yoursite.com/myblog/2018/08/10/初识Struts2/","excerpt":"","text":"Srtuts2运行基本流程首先客户端初始化一个指向Servlet的容器的请求，常用的容器就是Tomcat，请求被提交到 一系列的过滤器中；过滤器获取到请求路径，通过寻找src下面的Struts.xml核心配置文件 来找到需要调用的Action类，这里解析Struts.xml文件是通过dom4j技术来解析的；这里 获取对应的Action类的时候采用的是反射机制来实现的，然后得到相应的类的方法，调用 方法后得到一个返回值，再到struts.xml配置文件中找到对应的result，然后跳转到对应 页面。一个浅显的认识。 Srtuts2核心配置文件（主要的标签和属性）struts.xml是Struts2的核心配置文件，它主要负责管理应用中的Action的映射，以及该 Action包含的Result定义等；这里说一下struts.xml文件中的主要的标签和标签的属性的 意义； 1.首先是**&lt;struts&gt;&lt;/struts**&gt;标签，该标签是配置文件根标签。 2.**&lt;package&gt;&lt;/package&gt;**该标签使用包机制来解决同名action的兼容问题，里面有三个属 性，name属性可以根据自己来定义，extends一般是默认值struts-defalut，表示继承这 个包，namespace属性设置包的命令空间，一般为“ / &quot;;与action标签的name属性组成网 页访问地址，例如下图，如果要访问地址就是localhost：8080/yourProject/login.act ion； 3.**&lt;action&gt;&lt;/action&gt;**,name属性表示被请求action的名字，也是根据自己的需求来 取，没有特定的要求；class属性为你的action类的具体路径，method属性为当你的一个 action有多个方法，你要调用某一个方法的时候，就根据这个属性来判断；但是这种方法有 一个局限性，就是当一个action类中的方法特别多的时候，就需要写非常多的action标签； 因此这里可以采用通配符的方法来实现action的不同方法的访问；相比较而且这种方式是被 采用的更多的； 4.&lt;result&gt;&lt;/result&gt;标签，name属性为action类中的某一个方法的返回值，如果匹配成 攻，则控制页面进行对应的跳转，这也就是这个标签的主要作用，type属性表示页面跳转采 用的方式，默认为请求转发方式，还可以选择重定向方式来进行页面的跳转； Srtuts2常量配置在struts2中配置常量的方式有三种，在strucs.xml文件中配置，在web.xml文件中配置， 在struts.propreties文件中配置；通常采用struts.xml文件中进行配置，便于集中的管 理；一般常用的常量配置如下图； Srtuts2分模块开发可以单独写配置文件，把配置文件引入到核心配置文件中；意思就是一个在src中的struts. xml文件中不进行相应的标签声明，而是在相应的action类包中引入一个.xml文件，文件头 部跟struts.xml文件的一样，然后你在这个文件中进行相应的配置；最后在struts.xml文 件通过include标签对这个xml文件进行引入； Srtuts2中Action的编写方式action编写有三种方式； 1.创建普通类，不继承任何类，不实现任何接口； 2.创建类，实现Action接口，很少用； 3.创建类，继承类ActionSupport，最常用的方式，看ActionSupport的源码发现其实它已经实现了Action接口； Srtuts2中Action的不同方法的访问方式有三种访问方式；1.使用action的标签的method属性，在这个属性里面执行action方法； 2.使用通配符方式实现，开发中常用的方式，如下图，在其中method属性 的写法为{1}中间的数据根据name属性中的*号的个数来决定的，学过java 基础的不难理解； 3.动态访问实现（不常用）；","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"http://yoursite.com/tags/学习日记/"}]},{"title":"Linux压缩解压命令","slug":"Linux压缩解压命令","date":"2018-08-09T11:31:01.000Z","updated":"2018-08-09T11:51:44.454Z","comments":true,"path":"/myblog/2018/08/09/Linux压缩解压命令/","link":"","permalink":"http://yoursite.com/myblog/2018/08/09/Linux压缩解压命令/","excerpt":"","text":"在Linux中的压缩格式.gz，对应的命令gzip 语法：gzip 【文件名】 注意：只能压缩文件！ 解压缩文件命令：gunzip 语法：gunzip 【文件名】 等同于 gzip -d； 压缩目录：tar 语法：tar -【cvfz】 【压缩后的文件名】 【被压缩目录】 注意：压缩后的格式为.tar.gz； -z表示在打包的时候同时生成压缩文件。 一般使用tar -cjf； 解压目录：tar 语法：tar -【zxvf】 【压缩后的文件名】 【被压缩目录】 一般使用tar -xjf； 另一种压缩格式.zip，对应的命令为zip 语法：zip 选项【-r】 【压缩后的文件名】 【被压缩目录或文件】；-r表示压缩目录 对应的解压缩命令：unzip 语法：unzip 【压缩文件】 还有一种压缩格式.bz2，对应命令为bzip2 语法：bzip2 【-k】 【文件】；-k表示压缩文件后保留原文件 对应的解压缩命令为：bunzip2 语法：bunzip2 【-k】 【压缩文件】；-k表示解压缩之后保留原文件","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"http://yoursite.com/tags/学习日记/"}]},{"title":"Linux文件搜索命令","slug":"Linux文件搜索命令","date":"2018-08-09T08:42:33.000Z","updated":"2018-08-09T11:27:42.942Z","comments":true,"path":"/myblog/2018/08/09/Linux文件搜索命令/","link":"","permalink":"http://yoursite.com/myblog/2018/08/09/Linux文件搜索命令/","excerpt":"","text":"文件搜索命令：find 语法：find 【搜索范围】 【匹配条件】 find -name 根据文件名字搜索 注意如果文件名中包含你的*name* 都会搜索出来 *号相当于通配符，匹配任意个数字符 ？号匹配单个任意字符 find -iname不区分大小写查找文件 注意：在搜索的时候，条件越精确越好，节省资源 find -size【+-】 在目录下根据文件大小来查找文件 find -home根据所有者查找 find -group根据所属组查找 find -amin查找5分钟内被修改过访问时间属性的文件和目录 find -size 【条件】 -a 【条件】 -a表示条件连接，必须两个 件同时满足，-o是只用满足某一个条件 文件搜索命令：loacte 在文件资料库中寻找文件 语法：locate 【文件名】，搜索速度快，但locate不能实时查找，要想实时查找必须实时 更新资料库； 文件搜索命令：which 查找命令所在的目录及别名 语法：which 【命令名】 文件搜素命令：whereis 查找命令所在目录及帮助文档路径 语法：whereis 【命令名】 文件搜素命令：grep 在文件内容中进行字串匹配的查找 语法：grep 【关键词】 【文件名】 注意：grep -i 【关键词】 【文件名】 不区分大小写查询 grep -v排除指定字串；经常使用的命令 帮助命令：man 查看命令的详细信息 语法：man 【命令名】 帮助命令：help 查看内置命令的详细信息 语法：help 【命令名】 添加新用户：useradd 语法：useradd 【用户名】 设置用户密码：passwd 语法：passwd 【用户名】","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"http://yoursite.com/tags/学习日记/"}]},{"title":"Linux文件处理命令","slug":"linux命令","date":"2018-08-09T08:36:48.000Z","updated":"2018-08-09T08:40:00.664Z","comments":true,"path":"/myblog/2018/08/09/linux命令/","link":"","permalink":"http://yoursite.com/myblog/2018/08/09/linux命令/","excerpt":"","text":"显示目录文件命令：ls(list) 命令所在路径/bin/ls，执行权限所有用户都可以； 语法：ls 【选项 -a -l -d -lh】 【文件目录】 -a的意思是显示所有文件，包括隐藏文件； -l是显示详细信息； -d仅显示目录名； -lh显示通俗易懂的； 注意：在linux里面要想隐藏一个文件，就只有重命名，改成.开头的文件名格式； 如上图，以.开头的文件都是隐藏文件，使用ls命令是看不到的，只有ls -a才能看到这些 藏文件；-l就是显示文件的详细信息，可以看到第一行 drwxr-xr-x 这样的一个字段 这个字段标识u、g、o三类用户对这个文件拥有的权限。 创建目录命令：mkdir(make directories) 命令所在路径/bin/mkdir； 执行权限所有用户； 功能就是创建新目录； 可以一次创建单个目录或多个目录；例如mkdir /tmp/test01/a.txt或者mkdir /tmp test01/b.txt /tmp/test01/c.txt; 切换目录命令：cd(change directory) 命令的功能就是进行目录的切换； 切换到指定目录：cd /tmp/vae 回到上一级目录：cd .. 还是在当前目录：cd . 返回上两级目录：cd ../.. 返回进入此目录之前所在的目录：cd - 显示当前目录命令：pwd(print working directory) 用法就是直接在当前目录下使用pwd 删除空目录命令：rmdir(remove empty directory) 功能是删除指定空目录，但如果目录下有文件是不能删除的； 目录复制命令：cp 语法：cp 【源文件目录】 【目标文件目录】； -p：保留文件属性 linux在复制的过程中可以同时改变文件的名称； 目录剪切和更名命令：mv 语法：mv 【源文件目录】 【目标文件目录】； 在同一个目录下面进行mv操作 就是进行文件重命名； 文件删除命令：rm 语法：rm 【文件名】； rm -f 表示强制删除文件 rm -rf 表示强制删除一个目录 注意：在删除任何文件前，都做好备份工作 文件创建命令：touch 语法：在当前目录下，直接touch 【想创建的文件名】 注意：不建议在linux文件名字中使用空格等特殊符号，这会引起后续操作的麻烦 文件浏览命令：cat 语法：cat 【目标文件路径】 可以用tac命令；倒着显示； 长文件浏览命令：more 语法：more 【文件目录】 然后按空格或f进行翻页，按回车进行换行，按q或Q推出浏览状态，但不能向上翻页 长文件浏览命令：less 语法：less 【文件名】 功能跟more一样，还能向上翻页，还能进行搜索 看前几行浏览命令：head 语法：head -n 【文件名】；n表示你要显示的行数 看最后几行浏览命令：tail 语法：tail -n 【文件名】 tail -f 【文件名】动态显示文件末尾内容，多用于查看服务器log记录 链接命令：ln 语法：ln -s 【源文件】 【目标文件】 只要看到第一个字段以l开头，就说明这是一个软链接文件，类似windows系统中的快捷方式 软链接文件前面的用户权限全部为rwx；","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"http://yoursite.com/tags/学习日记/"}]},{"title":"Linux权限管理命令","slug":"Linux权限管理命令","date":"2018-08-09T08:36:48.000Z","updated":"2018-08-09T08:40:59.852Z","comments":true,"path":"/myblog/2018/08/09/Linux权限管理命令/","link":"","permalink":"http://yoursite.com/myblog/2018/08/09/Linux权限管理命令/","excerpt":"","text":"权限管理命令：chmod 执行权限是所有用户； 语法：chmod 【{ugoa}{+-=}{rwx}】 【文件目录】 注意：chmod -R递归修改；改变某一个目录下以及这个目录下的所 文件的权限 改变文件或目录的所有者：chown 语法：chown 【用户】 【文件或目录】 注意：改变的用户必须是系统里面有的用户角色 改变文件或目录的所属组：chgrp 语法：chgrp 【用户组】 【文件或目录】 显示、设置文件的缺省权限：umask 语法：umask -S","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"http://yoursite.com/tags/学习日记/"}]}]}